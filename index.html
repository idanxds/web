<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Merged Word Finder</title>

<style>
:root{
  --bg-color: #0f1724; --box-color: #0b1220; --input-bg-color:#0b1220; --text-color:#e6eef8;
  --text-muted-color:#9aa6b2; --header-color:#7dd3fc; --primary-color:#7dd3fc; --secondary-color:#60a5fa;
  --history-bg:#0a1622; --history-box-bg:#071225; --history-border:#15324a; --copied-color-start:#00e5ff; --copied-color-end:#84ffff;
  --game-mode-color:#f59e0b; --reset-color:#ef4444; --include-color:#10b981; --exclude-color:#ef4444; --bomb-selected-color:#f97316; --check-color:#a3e635;
}
body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 0; transition: background-color 0.3s, color 0.3s; display: flex; flex-direction: column; min-height: 100vh; box-sizing: border-box; }
/* Top History Panel - Horizontal */
#history-panel { position: fixed; top: 0; left: 0; width: 100%; height: 250px; background-color: var(--history-bg); color: var(--text-color); padding: 1rem; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); transform: translateY(-100%); transition: transform 0.3s ease-in-out; z-index: 1000; overflow-y: auto; }
#history-panel.open { transform: translateY(0); }
#history-content { display: flex; flex-wrap: nowrap; gap: 15px; overflow-x: auto; padding-bottom: 10px; }
.game-session { min-width: 250px; background: var(--history-box-bg); border-radius: 8px; padding: 10px; border: 1px solid var(--history-border); flex-shrink: 0; }

/* New Header Layout */
#header-bar { display: flex; justify-content: space-between; align-items: center; padding: 20px; background: var(--box-color); box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); position: relative; z-index: 900; gap: 20px; }
#left-buttons, #right-buttons { display: flex; gap: 10px; flex-wrap: wrap; }
#search-form-container { display: flex; gap: 10px; align-items: center; }

/* Side Panels */
.side-panel { position: fixed; top: 0; height: 100%; width: 320px; background: var(--box-color); padding: 2rem; box-shadow: 0 0 20px rgba(0, 0, 0, 0.3); transition: transform 0.3s ease-in-out; z-index: 999; overflow-y: auto; }
.side-panel.left { left: 0; transform: translateX(-100%); }
.side-panel.right { right: 0; transform: translateX(100%); }
.side-panel.open { transform: translateX(0); }
.side-panel h2 { margin-top: 0; border-bottom: 2px solid var(--secondary-color); padding-bottom: 10px; }
.panel-close-btn { position: absolute; top: 10px; right: 10px; background: var(--reset-color); padding: 5px 10px; font-size: 1.2rem; color: white; border: none; cursor: pointer; }
.option-btn { display: block; width: 100%; margin: 10px 0; text-align: left; padding: 12px; font-size: 1rem; background: transparent; color: var(--text-color); border: 1px solid transparent; border-radius: 6px; cursor: pointer; }
.option-btn.selected { background-color: var(--check-color); color: #111; }

/* Length Panel Special Styles */
#length-input { font-size: 1rem; padding: 0.75rem; border: 1px solid var(--history-border); border-radius: 8px; background-color: var(--input-bg-color); color: var(--text-color); width: 100%; margin: 10px 0; }
.length-btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 10px 0; }
#range-input-container { display: none; margin: 10px 0; }
#range-input-container.active { display: flex; gap: 5px; align-items: center; flex-wrap: wrap; }
#range-input-container input { width: 60px; padding: 5px; border: 1px solid var(--history-border); border-radius: 4px; background-color: var(--input-bg-color); color: var(--text-color); }

/* Main Content Area */
#main-content { flex: 1; display: flex; justify-content: center; align-items: flex-start; padding: 2rem; }
#results-container { background: var(--box-color); border-radius: 12px; padding: 2rem; box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1); width: 100%; max-width: 1200px; min-height: 300px; text-align: center; }

/* small utilities */
.btn { padding:8px 10px; border-radius:6px; border:none; cursor:pointer; background:transparent; color:var(--text-color); }
.filter-tag { display:inline-flex; gap:6px; align-items:center; padding:6px 8px; border-radius:6px; background:var(--history-box-bg); margin:4px; }
.remove-tag-btn { background:none; border:none; color:var(--reset-color); cursor:pointer; margin-left:6px; }
</style>

</head>

<body class="dark-theme">
    <!-- Top History Panel (Horizontal) -->
    <div id="history-panel">
        <h2>History <span id="history-count">(0)</span></h2>
        <button class="panel-close-btn" id="close-history-btn">Ã—</button>
        <input type="text" id="history-search-bar" placeholder="Search history..." style="width: 100%; padding: 8px; margin-bottom: 10px; border-radius: 4px; border: 1px solid var(--history-border); background: var(--input-bg-color); color: var(--text-color);">
        <div id="history-content"></div>
    </div>

    <!-- Header -->
    <div id="header-bar">
        <div id="left-buttons">
            <button id="unique-filter-btn" class="btn">Unique Filter</button>
            <button id="sort-filter-btn" class="btn">Sort</button>
            <button id="length-filter-btn" class="btn">Length</button>
            <button id="caps-filter-btn" class="btn">Caps</button>
            <button id="include-exclude-btn" class="btn">Include/Exclude</button>
        </div>

        <div id="search-form-container">
            <form id="search-form">
                <input type="text" id="search-input" placeholder="e.g., s_a_e" autocomplete="off" style="padding:8px;border-radius:6px;border:1px solid var(--history-border);background:var(--input-bg-color);color:var(--text-color);">
                <button type="submit" id="search-button" class="btn">Find</button>
            </form>
        </div>

        <div id="right-buttons">
            <button id="game-toggle-button" class="btn">Start Game</button>
            <button id="reset-button" class="btn">Reset Colors</button>
            <button id="theme-toggle-button" class="btn">Theme</button>
            <button id="toggle-history-button" class="btn">History</button>
            <button id="stats-button" class="btn">Stats</button>
            <button id="prompt-page-button" class="btn">Prompts</button>
            <button id="define-toggle-button" class="btn">Define</button>
            <button id="crazy-mode-button" class="btn">Crazy Mode</button>
        </div>
    </div>

    <!-- Main Content -->
    <div id="main-content">
        <div id="loading-message">Loading word files...</div>
        <div id="results-container" style="display: none;"></div>
    </div>

    <!-- Left Side Panel -->
    <div id="left-panel" class="side-panel left">
        <button class="panel-close-btn">Ã—</button>
        <div id="left-panel-content"></div>
    </div>

    <!-- Right Side Panel -->
    <div id="right-panel" class="side-panel right">
        <button class="panel-close-btn">Ã—</button>
        <div id="right-panel-content"></div>
    </div>
</body>

<script>
/* --- Combined original scripts (merged) --- */

        document.addEventListener('DOMContentLoaded', () => {

            // --- Element References ---
            const searchForm = document.getElementById('search-form');
            const searchInput = document.getElementById('search-input');
            const searchFilter = document.getElementById('search-filter');
            const capFilter = document.getElementById('cap-filter');
            const lengthFilter = document.getElementById('length-filter');
            const uniqueFilter = document.getElementById('unique-filter');
            const resultsContainer = document.getElementById('results-container');
            const loadingMessage = document.getElementById('loading-message');
            const resetButton = document.getElementById('reset-button');
            const gameToggleButton = document.getElementById('game-toggle-button');
            const toggleHistoryButton = document.getElementById('toggle-history-button');
            const closeHistoryButton = document.getElementById('close-history-button');
            const historyPanel = document.getElementById('history-panel');
            const historyContent = document.getElementById('history-content');
            const historyHeader = document.getElementById('history-header');
            const themeToggleButton = document.getElementById('theme-toggle-button');
            const softlockButton = document.getElementById('softlock-button');
            const tooltip = document.getElementById('word-tooltip');
            const statsButton = document.getElementById('stats-button');
            const statsModalOverlay = document.getElementById('stats-modal-overlay');
            const statsCloseButton = document.getElementById('stats-close-button');
            const statTotalWords = document.getElementById('stat-total-words');
            const statFreqWords = document.getElementById('stat-freq-words');
            const statAvgLength = document.getElementById('stat-avg-length');
            const statsChart = document.getElementById('stats-chart');
            const addIncludeButton = document.getElementById('add-include-button');
            const addExcludeButton = document.getElementById('add-exclude-button');
            const includeListTags = document.getElementById('include-list-tags');
            const excludeListTags = document.getElementById('exclude-list-tags');
            const historySearchInput = document.getElementById('history-search-bar');
            const statTotalCopied = document.getElementById('stat-total-copied');
            const statGameSessions = document.getElementById('stat-game-sessions');
            const statAvgWordsGame = document.getElementById('stat-avg-words-game');
            const mainAppDiv = document.getElementById('main-app');
            const promptPageButton = document.getElementById('prompt-page-button');
            const promptsPageDiv = document.getElementById('prompts-page');
            const promptHomeButton = document.getElementById('prompt-home-button');
            const promptSort = document.getElementById('prompt-sort');
            const promptsListContainer = document.getElementById('prompts-list-container');
            const defineToggleButton = document.getElementById('define-toggle-button');
            const defineModalOverlay = document.getElementById('define-modal-overlay');
            const defineModalTitle = document.getElementById('define-modal-title');
            const defineModalBody = document.getElementById('define-modal-body');
            const defineCloseButton = document.getElementById('define-close-button');
            const defineModalNav = document.querySelector('.modal-tab-nav');
            const defineSearchForm = document.getElementById('define-search-form');
            const defineSearchInput = document.getElementById('define-search-input');
            const subsearchPageButton = document.getElementById('subsearch-page-button');
            const subsearchPageDiv = document.getElementById('subsearch-page');
            const subsearchHomeButton = document.getElementById('subsearch-home-button');
            const subsearchForm = document.getElementById('subsearch-form');
            const subsearchInput = document.getElementById('subsearch-input');
            const subsearchList = document.getElementById('subsearch-results-list');
            const crazyModeButton = document.getElementById('crazy-mode-button');

            // --- State Variables ---
            let masterWordSet = new Set();
            let allCleanWords = [];
            let nameList = new Set();
            let wordFrequencyMap = new Map();
            let wordCopyCountMap = new Map();
            let allCopiedWords = new Set();
            let threeLetterPromptMap = new Map();
            let promptsByCountMap = new Map();
            let dictionaryStats = {
                totalWords: 0,
                freqWords: 0,
                avgLength: 0,
                lengthDistribution: new Map(),
                maxLength: 0
            };
            let copiedWordsHistory = [];
            let gameSessions = [];
            let isGameMode = false;
            let currentGameSession = null;
            let permanentIncludeList = [];
            let permanentExcludeList = [];
            let isSoftlocked = false;
            let softlockBuffer = "";
            let currentTheme = 0;
            const themes = ['dark-theme', 'light-theme', 'retro-theme'];
            const MAX_RESULTS_TO_DISPLAY = 300;
            const synth = window.speechSynthesis;
            let wordBombList = new Set();
            let wordBombSelected = new Set();
            let isDefineMode = false;
            let isCrazyMode = false;
            
            const countryList = [
                "afghanistan", "albania", "algeria", "andorra", "angola", "antigua and barbuda", "argentina", "armenia", "australia", "austria", 
                "austrian empire", "azerbaijan", "baden", "bahamas, the", "bahrain", "bangladesh", "barbados", "bavaria", "belarus", "belgium", 
                "belize", "benin (dahomey)", "bolivia", "bosnia and herzegovina", "botswana", "brazil", "brunei", "brunswick and lÃ¼neburg", "bulgaria", 
                "burkina faso (upper volta)", "burma", "burundi", "cabo verde", "cambodia", "cameroon", "canada", "cayman islands, the", 
                "central african republic", "central american federation", "chad", "chile", "china", "colombia", "comoros", "congo free state, the", 
                "cook islands", "costa rica", "cote dâ€™ivoire (ivory coast)", "croatia", "cuba", "cyprus", "czechia", "czechoslovakia", 
                "democratic republic of the congo", "denmark", "djibouti", "dominica", "dominican republic", "duchy of parma, the", "east germany (german democratic republic)", 
                "ecuador", "egypt", "el salvador", "equatorial guinea", "eritrea", "estonia", "eswatini", "ethiopia", "federal government of germany (1848-49)", 
                "fiji", "finland", "france", "gabon", "gambia, the", "georgia", "germany", "ghana", "grand duchy of tuscany, the", "greece", 
                "grenada", "guatemala", "guinea", "guinea-bissau", "guyana", "haiti", "hanover", "hanseatic republics", "hawaii", "hesse", 
                "holy see", "honduras", "hungary", "iceland", "india", "indonesia", "iran", "iraq", "ireland", "israel", "italy", "jamaica", 
                "japan", "jordan", "kazakhstan", "kenya", "kingdom of serbia/yugoslavia", "kiribati", "korea", "kosovo", "kuwait", "kyrgyzstan", 
                "laos", "latvia", "lebanon", "lesotho", "lew chew (loochoo)", "liberia", "libya", "liechtenstein", "lithuania", "luxembourg", 
                "madagascar", "malawi", "malaysia", "maldives", "mali", "malta", "marshall islands", "mauritania", "mauritius", "mecklenburg-schwerin", 
                "mecklenburg-strelitz", "mexico", "micronesia", "moldova", "monaco", "mongolia", "montenegro", "morocco", "mozambique", "namibia", 
                "nassau", "nauru", "nepal", "netherlands, the", "new zealand", "nicaragua", "niger", "nigeria", "niue", "north german confederation", 
                "north german union", "north macedonia", "norway", "oldenburg", "oman", "orange free state", "pakistan", "palau", "panama", 
                "papal states", "papua new guinea", "paraguay", "peru", "philippines", "piedmont-sardinia", "poland", "portugal", "qatar", 
                "republic of genoa", "republic of korea (south korea)", "republic of the congo", "romania", "russia", "rwanda", "saint kitts and nevis", 
                "saint lucia", "saint vincent and the grenadines", "samoa", "san marino", "sao tome and principe", "saudi arabia", "schaumburg-lippe", 
                "senegal", "serbia", "seychelles", "sierra leone", "singapore", "slovakia", "slovenia", "solomon islands, the", "somalia", "south africa", 
                "south sudan", "spain", "sri lanka", "sudan", "suriname", "sweden", "switzerland", "syria", "tajikistan", "tanzania", "texas", 
                "thailand", "timor-leste", "togo", "tonga", "trinidad and tobago", "tunisia", "turkey", "turkmenistan", "tuvalu", "two sicilies", 
                "uganda", "ukraine", "union of soviet socialist republics", "united arab emirates, the", "united kingdom, the", "uruguay", "uzbekistan", 
                "vanuatu", "venezuela", "vietnam", "wÃ¼rttemberg", "yemen", "zambia", "zimbabwe"
            ];

            // --- Utility Functions ---
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }
            
            function escapeRegExp(string) {
                return string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
            }

            function highlightQuery(word, query) {
                let highlightedWord = word;
                let queriesToHighlight = [];
                if (query) queriesToHighlight.push(query);
                
                const filterType = uniqueFilter.value;

                if (filterType !== 'include-all') {
                    permanentIncludeList.forEach(item => queriesToHighlight.push(item));
                }
                
                const safeQueries = queriesToHighlight
                    .filter(q => q && q.length > 0)
                    .map(escapeRegExp);
                
                if (safeQueries.length > 0) {
                    const regex = new RegExp(`(${safeQueries.join('|')})`, 'gi');
                    highlightedWord = word.replace(regex, '<span class="highlight">$1</span>');
                }
                
                
                if (filterType === 'pattern' && query) {
                     try {
                        const queryPattern = query.replace(/_/g, '.');
                        highlightedWord = highlightedWord.replace(new RegExp(`(${queryPattern})`, 'gi'), (match) => {
                            let highlightedMatch = '';
                            for(let i = 0; i < match.length; i++) {
                                let char = match[i];
                                if (query[i] !== '_' && !char.includes('span')) {
                                    highlightedMatch += `<span class="highlight">${char}</span>`;
                                } else {
                                    highlightedMatch += char;
                                }
                            }
                            return highlightedMatch;
                        });
                    } catch(e) { /* ignore */ }
                }
                if (filterType === 'v-c-pattern' && query) {
                    try {
                        highlightedWord = highlightedWord.replace(/[bcdfghjklmnpqrstvwxyz]/gi, (match) => {
                            if (match.includes('span')) return match;
                            return `<strong>${match}</strong>`;
                        });
                        highlightedWord = highlightedWord.replace(/[aeiouy]/gi, (match) => {
                            if (match.includes('span')) return match;
                            return `<span class="highlight">${match}</span>`;
                        });
                    } catch(e) { /* ignore */ }
                }
                if (filterType === 'include-all' && query) {
                    try {
                        const regex = new RegExp(`([${escapeRegExp(query)}])`, 'gi');
                        highlightedWord = highlightedWord.replace(regex, '<span class="highlight">$1</span>');
                    } catch(e) { /* ignore */ }
                }
                return highlightedWord;
            }

            function getCharMap(word) {
                const map = {};
                for (const char of word) {
                    map[char] = (map[char] || 0) + 1;
                }
                return map;
            }
            
            // --- Capping Functions (Unchanged) ---
            function applyRandomLetterCaps(word) {
                return word.split('').map(char => 
                    Math.random() < 0.5 ? char.toUpperCase() : char
                ).join('');
            }
            function getEffectiveCapMode() {
                let mode = capFilter.value;
                if (mode === 'random-mode') {
                    const modes = ['none', 'all', 'random-letter'];
                    mode = modes[Math.floor(Math.random() * modes.length)];
                }
                return mode;
            }
            function applyCapping(word, mode) {
                switch (mode) {
                    case 'all': return word.toUpperCase();
                    case 'random-letter': return applyRandomLetterCaps(word);
                    case 'none': default: return word;
                }
            }
            
            // --- localStorage Functions (Unchanged) ---
            function saveState() {
                try {
                    localStorage.setItem('wordFinderGameSessions', JSON.stringify(gameSessions));
                    localStorage.setItem('wordFinderCopyCounts', JSON.stringify(Array.from(wordCopyCountMap.entries())));
                    localStorage.setItem('wordFinderTheme', themes[currentTheme]);
                    localStorage.setItem('wordFinderBombList', JSON.stringify(Array.from(wordBombList)));
                    localStorage.setItem('wordFinderIncludeList', JSON.stringify(permanentIncludeList));
                    localStorage.setItem('wordFinderExcludeList', JSON.stringify(permanentExcludeList));
                } catch (e) { console.error("Failed to save state:", e); }
            }
            function loadState() {
                const savedGames = localStorage.getItem('wordFinderGameSessions');
                if (savedGames) {
                    try { gameSessions = JSON.parse(savedGames); } catch (e) { gameSessions = []; }
                }
                const savedCounts = localStorage.getItem('wordFinderCopyCounts');
                if (savedCounts) {
                    try { 
                        wordCopyCountMap = new Map(JSON.parse(savedCounts));
                        allCopiedWords = new Set(wordCopyCountMap.keys());
                    } catch (e) { 
                        wordCopyCountMap = new Map(); 
                        allCopiedWords = new Set();
                    }
                }
                
                migrateOldData();
                
                const savedTheme = localStorage.getItem('wordFinderTheme');
                if (savedTheme && themes.includes(savedTheme)) {
                    currentTheme = themes.indexOf(savedTheme) - 1;
                } else {
                    currentTheme = -1; 
                }
                toggleTheme();
                
                const savedBombList = localStorage.getItem('wordFinderBombList');
                if (savedBombList) {
                    try { wordBombList = new Set(JSON.parse(savedBombList)); } catch (e) { wordBombList = new Set(); }
                }
                const savedIncludeList = localStorage.getItem('wordFinderIncludeList');
                if (savedIncludeList) {
                    try { permanentIncludeList = JSON.parse(savedIncludeList); } catch (e) { permanentIncludeList = []; }
                }
                const savedExcludeList = localStorage.getItem('wordFinderExcludeList');
                if (savedExcludeList) {
                    try { permanentExcludeList = JSON.parse(savedExcludeList); } catch (e) { permanentExcludeList = []; }
                }
                updateHistoryPanel();
                renderIncludeExcludeTags();
            }
            
            // --- Data Migration Function ---
            function migrateOldData() {
                let migratedCount = 0;
                gameSessions.forEach(session => {
                    session.words.forEach(item => {
                        let word = null;
                        if(typeof item === 'string') word = item;
                        else if (typeof item === 'object' && item.word) word = item.word;
                        
                        if (word && !allCopiedWords.has(word)) {
                            allCopiedWords.add(word);
                            wordCopyCountMap.set(word, 1);
                            migratedCount++;
                        }
                    });
                });
                copiedWordsHistory.forEach(item => {
                     let word = null;
                    if(typeof item === 'string') word = item;
                    else if (typeof item === 'object' && item.word) word = item.word;
                     
                    if (word && !allCopiedWords.has(word)) {
                        allCopiedWords.add(word);
                        wordCopyCountMap.set(word, 1);
                        migratedCount++;
                    }
                });
                
                if (migratedCount > 0) {
                    console.log(`Migrated ${migratedCount} words from old history to new stats system.`);
                    saveState();
                }
            }
            
            // --- History Panel Functions (Unchanged) ---
            function updateHistoryCounter() {
                const total = copiedWordsHistory.length + gameSessions.reduce((acc, s) => acc + s.words.length, 0);
                toggleHistoryButton.textContent = `History (${total})`;
            }
            function updateHistoryPanel() {
                const searchTerm = historySearchInput.value.toLowerCase();
                historyContent.innerHTML = '';
                
                gameSessions.forEach(session => {
                    const sessionMatches = session.name.toLowerCase().includes(searchTerm) ||
                                       (session.words && session.words.some(item => item.word.includes(searchTerm)));
                    if (!searchTerm || sessionMatches) {
                        const sessionElement = document.createElement('details');
                        sessionElement.open = !!searchTerm;
                        const isLocked = (session !== currentGameSession);
                        sessionElement.className = `game-session ${isLocked ? 'locked' : ''}`;
                        sessionElement.dataset.sessionId = session.id;
                        const summary = document.createElement('summary');
                        const sessionName = document.createElement('span');
                        sessionName.className = 'session-name';
                        sessionName.textContent = session.name;
                        const sessionControls = document.createElement('div');
                        sessionControls.className = 'session-controls';
                        const renameBtn = document.createElement('button');
                        renameBtn.className = 'btn rename-btn'; renameBtn.textContent = 'Rename';
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'btn delete-session-btn'; deleteBtn.textContent = 'Delete';
                        sessionControls.appendChild(renameBtn); sessionControls.appendChild(deleteBtn);
                        summary.appendChild(sessionName); summary.appendChild(sessionControls);
                        const wordList = document.createElement('ul');
                        wordList.className = 'session-word-list';
                        
                        session.words.forEach(item => {
                            if (!searchTerm || item.word.includes(searchTerm)) {
                                const li = document.createElement('li');
                                li.innerHTML = `
                                    <div>
                                        <span>${highlightQuery(item.word, item.query)}</span>
                                        <small class="history-word-info">
                                            (Query: ${item.query || 'n/a'}, Filter: ${item.filter}, Caps: ${item.caps})
                                        </small>
                                    </div>
                                    <button class="delete-word-btn" data-word="${item.word}">Ã—</button>
                                `;
                                wordList.appendChild(li);
                            }
                        });
                        sessionElement.appendChild(summary); sessionElement.appendChild(wordList);
                        historyContent.appendChild(sessionElement);
                    }
                });
                
                if (gameSessions.length > 0 && copiedWordsHistory.length > 0) {
                    historyContent.appendChild(document.createElement('hr')).className = 'history-divider';
                }
                
                copiedWordsHistory.forEach(item => {
                    if (!searchTerm || item.word.includes(searchTerm)) {
                        const itemElement = document.createElement('div');
                        itemElement.className = 'history-item';
                        itemElement.innerHTML = `
                            <span>${highlightQuery(item.word, item.query)}</span>
                            <small class="history-word-info">
                                (Query: ${item.query || 'n/a'}, Filter: ${item.filter}, Caps: ${item.caps})
                            </small>
                        `;
                        historyContent.appendChild(itemElement);
                    }
                });
                
                updateHistoryCounter();
                historyHeader.textContent = `History`;
            }
            
            // --- Core Logic (File loading & findWords are unchanged) ---
            async function loadAndProcessFile() {
                try {
                    const responseMaster = await fetch('initial_dictionary.txt');
                    const contentTypeMaster = responseMaster.headers.get("content-type");
                    if (!responseMaster.ok || !contentTypeMaster || !contentTypeMaster.includes("text/plain")) {
                        throw new Error(`Failed to load 'initial_dictionary.txt'. Status: ${responseMaster.status}. Content-Type: ${contentTypeMaster}.`);
                    }
                    const textMaster = await responseMaster.text();
                    textMaster.split('\n').forEach(line => {
                        const word = line.trim().toLowerCase();
                        if (word.length > 0) masterWordSet.add(word);
                    });
                    allCleanWords = Array.from(masterWordSet);
                    console.log(`Master list loaded: ${allCleanWords.length} unique words.`);

                    const responseFreq = await fetch('word_freq_list.txt');
                    const contentTypeFreq = responseFreq.headers.get("content-type");
                    if (responseFreq.ok && contentTypeFreq && contentTypeFreq.includes("text/plain")) {
                        const textFreq = await responseFreq.text();
                        let loadedFrequencies = 0;
                        textFreq.split('\n').forEach(line => {
                            const parts = line.split(',');
                            if (parts.length === 2) {
                                const word = parts[0].trim().toLowerCase();
                                const count = parseInt(parts[1].trim(), 10);
                                if (masterWordSet.has(word) && !isNaN(count)) {
                                    wordFrequencyMap.set(word, count);
                                    loadedFrequencies++;
                                }
                            }
                        });
                        console.log(`Frequency data loaded for ${loadedFrequencies} overlapping words.`);
                    } else {
                        console.log("No frequency file found or file was wrong type. 'Common' filters will be disabled.");
                        document.querySelector('option[value="common"]').disabled = true;
                        document.querySelector('option[value="least-common"]').disabled = true;
                    }
                    
                    const responseNames = await fetch('names_list.txt');
                    const contentTypeNames = responseNames.headers.get("content-type");
                    if (responseNames.ok && contentTypeNames && contentTypeNames.includes("text/plain")) {
                        const textNames = await responseNames.text();
                        textNames.split('\n').forEach(line => {
                            const name = line.trim().toLowerCase();
                            if (name.length > 0) nameList.add(name);
                        });
                        console.log(`Names list loaded: ${nameList.size} unique names.`);
                    } else {
                        console.log("No names_list.txt found. 'Names' filter will be disabled.");
                        document.querySelector('option[value="names"]').disabled = true;
                    }
                    
                    loadingMessage.style.display = 'none';
                    resultsContainer.style.display = 'block';
                    calculateStatsAndPrompts();
                    
                } catch (error) {
                    loadingMessage.textContent = `Error: ${error.message} Check file names and that the server is running.`;
                    console.error(error);
                }
            }

            // --- findWords (Updated) ---
            function findWords(query, uniqueFilterType, sortFilterType, lenFilter, wordsToExclude = []) {
                const excludeSet = new Set(wordsToExclude);
                let candidateWords = [];
                let patternRegex = null;
                let queryCharMap = null;
                let queryLetterSet = null;
                
                let sourceList;
                if (uniqueFilterType === 'by-countries') {
                    sourceList = countryList.filter(country => masterWordSet.has(country));
                } else if (uniqueFilterType === 'word-bomb') {
                    if (wordBombList.size === 0) return [];
                    sourceList = Array.from(wordBombList);
                } else if (uniqueFilterType === 'names') {
                    if (nameList.size === 0) return [];
                    sourceList = Array.from(nameList).filter(name => masterWordSet.has(name));
                } else {
                    sourceList = allCleanWords;
                }
                
                if (uniqueFilterType === 'pattern') {
                    try { patternRegex = new RegExp(query.replace(/_/g, '.'), 'i'); } catch (e) { return []; }
                }
                if (uniqueFilterType === 'v-c-pattern') {
                    try {
                        const pattern = query.replace(/v/gi, '[aeiouy]').replace(/c/gi, '[bcdfghjklmnpqrstvwxyz]');
                        patternRegex = new RegExp(`^${pattern}$`);
                    } catch (e) { return []; }
                }
                if (uniqueFilterType === 'anagram') {
                    queryCharMap = getCharMap(query);
                }
                if (uniqueFilterType === 'include-all') {
                    queryLetterSet = new Set(query.split(''));
                }

                for (const word of sourceList) {
                    if (excludeSet.has(word)) continue;
                    
                    if (uniqueFilterType !== 'by-countries') {
                        if (permanentExcludeList.length > 0 && permanentExcludeList.some(ex => word.includes(ex))) continue;
                        if (permanentIncludeList.length > 0 && !permanentIncludeList.every(inc => word.includes(inc))) continue;
                    }
                    
                    let matchesBase = false;
                    switch (uniqueFilterType) {
                        case 'pattern':
                        case 'v-c-pattern':
                            matchesBase = patternRegex.test(word);
                            break;
                        case 'anagram':
                            const wordCharMap = getCharMap(word);
                            matchesBase = true;
                            for (const char in wordCharMap) {
                                if (!queryCharMap[char] || wordCharMap[char] > queryCharMap[char]) {
                                    matchesBase = false; break;
                                }
                            }
                            break;
                        case 'include-all':
                            if (queryLetterSet) {
                                matchesBase = [...queryLetterSet].every(letter => word.includes(letter));
                            }
                            break;
                        default: // 'none', 'word-bomb', 'by-countries', 'names'
                            if(sortFilterType === 'starting') {
                                matchesBase = word.startsWith(query);
                            } else if (sortFilterType === 'ending') {
                                matchesBase = word.endsWith(query);
                            } else {
                                matchesBase = (query.length === 0) ? true : word.includes(query);
                            }
                            break;
                    }
                    if (matchesBase) {
                        candidateWords.push(word);
                    }
                }
                if (candidateWords.length === 0) return [];

                if (lenFilter !== 'any' && lenFilter !== 'longest' && lenFilter !== 'shortest') {
                    const length = parseInt(lenFilter, 10);
                    candidateWords = candidateWords.filter(w => w.length === length);
                }
                if (candidateWords.length === 0) return [];
                
                
                if (uniqueFilterType !== 'by-countries') {
                    switch (sortFilterType) {
                        case 'common': {
                            const candidatesWithFreq = candidateWords.filter(w => wordFrequencyMap.has(w));
                            if (candidatesWithFreq.length === 0) return [];
                            candidatesWithFreq.sort((a, b) => (wordFrequencyMap.get(b) || 0) - (wordFrequencyMap.get(a) || 0));
                            const mostCommonFreq = wordFrequencyMap.get(candidatesWithFreq[0]);
                            candidateWords = candidatesWithFreq.filter(w => wordFrequencyMap.get(w) === mostCommonFreq);
                            break;
                        }
                        case 'least-common': {
                            const candidatesWithFreq = candidateWords.filter(w => wordFrequencyMap.has(w));
                            if (candidatesWithFreq.length === 0) return [];
                            candidatesWithFreq.sort((a, b) => (wordFrequencyMap.get(a) || 0) - (wordFrequencyMap.get(b) || 0));
                            const leastCommonFreq = wordFrequencyMap.get(candidatesWithFreq[0]);
                            candidateWords = candidatesWithFreq.filter(w => wordFrequencyMap.get(w) === leastCommonFreq);
                            break;
                        }
                    }
                }
                
                if (lenFilter === 'longest') {
                    return candidateWords.sort((a, b) => b.length - a.length);
                }
                if (lenFilter === 'shortest') {
                    return candidateWords.sort((a, b) => a.length - b.length);
                }
                
                if (sortFilterType === 'common' || sortFilterType === 'least-common') {
                    return candidateWords;
                }
                
                return candidateWords;
            }
            
            // --- copyToClipboard (Updated) ---
            function copyToClipboard(formattedWord, originalWord, element, query = "") {
                navigator.clipboard.writeText(formattedWord).then(() => {
                    const count = (wordCopyCountMap.get(originalWord) || 0) + 1;
                    wordCopyCountMap.set(originalWord, count);
                    allCopiedWords.add(originalWord);
                    saveState();
                    
                    if (element) {
                        element.classList.add('copied');
                        element.dataset.tooltip = getTooltipText(originalWord);
                        // No "Copied!" text
                    } else {
                        const highlightedHtml = highlightQuery(formattedWord, query);
                        resultsContainer.innerHTML = `Copied: ${highlightedHtml}`;
                    }
                }).catch(err => console.error('Failed to copy text: ', err));
            }

            // --- addToHistory (Updated) ---
            function addToHistory(originalWord, query, uniqueFilterType, sortFilterType, capMode) {
                const combinedQuery = query || permanentIncludeList.join(',') || 'n/a';
                const newWordItem = { 
                    word: originalWord, 
                    query: combinedQuery, 
                    filter: `${uniqueFilterType} / ${sortFilterType}`,
                    caps: capMode, 
                    game: isGameMode 
                };
                
                if (isGameMode && currentGameSession) {
                    if (!currentGameSession.words.some(item => item.word === originalWord)) {
                        currentGameSession.words.push(newWordItem);
                        saveState();
                    }
                } else if (!isGameMode) {
                    if (uniqueFilterType !== 'by-countries' && uniqueFilterType !== 'names') {
                         if (!copiedWordsHistory.some(item => item.word === originalWord)) {
                            copiedWordsHistory.push(newWordItem);
                        }
                    }
                }
                updateHistoryPanel();
            }

            // --- handleSearch (Main routing) (Updated) ---
            function handleSearch(event) {
                if (event) event.preventDefault();
                const query = isSoftlocked ? softlockBuffer.trim().toLowerCase() : searchInput.value.trim().toLowerCase();
                
                if (isCrazyMode) {
                    runCrazySearch(query);
                    return; // Crazy mode handles its own search
                }
                
                const uniqueFilterType = uniqueFilter.value;
                const sortFilterType = searchFilter.value;
                const lenFilter = lengthFilter.value;
                const capMode = getEffectiveCapMode();
                
                if (isGameMode) {
                    handleGameSearch(query, uniqueFilterType, sortFilterType, lenFilter, capMode);
                } else {
                    handleNormalSearch(query, uniqueFilterType, sortFilterType, lenFilter, capMode);
                }
                if(isSoftlocked) {
                    softlockBuffer = "";
                }
            }
            
            // --- NEW: Crazy Search Function ---
            function runCrazySearch(query) {
                let foundWordsList = [];
                let uniqueFilterType, sortFilterType, lenFilter, capMode;
                
                let wordsToExclude = [];
                if (isGameMode && currentGameSession) {
                    wordsToExclude = Array.from(new Set(currentGameSession.words.map(item => item.word)));
                }

                let attempts = 0;
                do {
                    const capOptions = ['none', 'all', 'random-letter'];
                    capMode = capOptions[Math.floor(Math.random() * capOptions.length)];

                    const lengthOptions = ['longest', 'shortest'];
                    for (let i = 3; i <= dictionaryStats.maxLength; i++) {
                        lengthOptions.push(i.toString());
                    }
                    lengthOptions.push('any'); 
                    lenFilter = lengthOptions[Math.floor(Math.random() * lengthOptions.length)];
                    
                    const crazyFilters = [
                        { unique: 'none', sort: 'none' },
                        { unique: 'none', sort: 'common' },
                        { unique: 'none', sort: 'least-common' },
                        { unique: 'by-countries', sort: 'none' },
                        { unique: 'names', sort: 'none' },
                        { unique: 'none', sort: 'starting' },
                        { unique: 'none', sort: 'ending' }
                    ];
                    
                    const randomFilter = crazyFilters[Math.floor(Math.random() * crazyFilters.length)];
                    uniqueFilterType = randomFilter.unique;
                    sortFilterType = randomFilter.sort;
                    
                    foundWordsList = findWords(query, uniqueFilterType, sortFilterType, lenFilter, wordsToExclude);
                    attempts++;

                } while (foundWordsList.length === 0 && query.length > 0 && attempts < 50);

                if (foundWordsList.length === 0) {
                    resultsContainer.textContent = `Crazy Mode failed to find a match after 50 attempts! Try a different query.`;
                    return;
                }

                if (isGameMode) {
                    const randomWord = foundWordsList[Math.floor(Math.random() * foundWordsList.length)];
                    const formattedWord = applyCapping(randomWord, capMode);
                    copyToClipboard(formattedWord, randomWord, null, query);
                    addToHistory(randomWord, query, uniqueFilterType, sortFilterType, capMode);
                } else {
                    handleNormalSearch(query, uniqueFilterType, sortFilterType, lenFilter, capMode, foundWordsList);
                }
            }
            
            // --- getTooltipText (Unchanged) ---
            function getTooltipText(word) {
                const freq = wordFrequencyMap.get(word) || 'N/A';
                const copies = wordCopyCountMap.get(word) || 0;
                return `Length: ${word.length} | Freq: ${freq} | Copied: ${copies}`;
            }

            // --- handleNormalSearch (Unchanged) ---
            function handleNormalSearch(query, uniqueFilterType, sortFilterType, lenFilter, capMode, preFoundWordsList = null) {
                resultsContainer.innerHTML = '';
                if (query.length === 0 && permanentIncludeList.length === 0 && uniqueFilterType !== 'word-bomb' && uniqueFilterType !== 'anagram' && uniqueFilterType !== 'by-countries' && uniqueFilterType !== 'names') return;

                const foundWordsList = preFoundWordsList || findWords(query, uniqueFilterType, sortFilterType, lenFilter);
                
                if (foundWordsList.length === 0) {
                    resultsContainer.textContent = `No words found.`;
                    return;
                }

                let displayList = foundWordsList;
                
                if (sortFilterType === 'none' && lenFilter === 'any') {
                    shuffleArray(displayList);
                }
                
                const totalMatches = displayList.length;
                const wordsToDisplay = displayList.slice(0, MAX_RESULTS_TO_DISPLAY);
                const fragment = document.createDocumentFragment();
                const summary = document.createElement('div');
                summary.id = 'results-summary';
                summary.textContent = `Showing ${wordsToDisplay.length} of ${totalMatches} matching words.`;
                fragment.appendChild(summary);

                for (const originalWord of wordsToDisplay) {
                    const wordElement = document.createElement('span');
                    const formattedWord = applyCapping(originalWord, capMode);
                    const highlightedHtml = highlightQuery(formattedWord, query);
                    const ttsIcon = `<span class="tts-icon">ðŸ”Š</span>`;
                    wordElement.innerHTML = highlightedHtml + ttsIcon;
                    wordElement.className = 'word-item';
                    wordElement.dataset.originalWord = originalWord;
                    
                    if (allCopiedWords.has(originalWord)) {
                        wordElement.classList.add('copied');
                    }
                    if (wordBombSelected.has(originalWord)) {
                        wordElement.classList.add('word-bomb-selected');
                    }
                    fragment.appendChild(wordElement);
                }
                resultsContainer.appendChild(fragment);
            }

            // --- handleGameSearch (Unchanged) ---
            function handleGameSearch(query, uniqueFilterType, sortFilterType, lenFilter, capMode) {
                if (query.length < 1 && permanentIncludeList.length < 1) { 
                    resultsContainer.textContent = 'Game Mode: Please enter letters to search.';
                    return;
                }
                if (!currentGameSession) {
                    resultsContainer.textContent = 'Error: No active game session.';
                    return;
                }
                const usedWordsInThisGame = new Set(currentGameSession.words.map(item => item.word));
                const unusedMatches = findWords(query, uniqueFilterType, sortFilterType, lenFilter, Array.from(usedWordsInThisGame));

                if (unusedMatches.length === 0) {
                    resultsContainer.textContent = `No *new* words found.`;
                    return;
                }
                
                let finalCandidates = unusedMatches;
                
                let tieBreakerList = [];
                if (uniqueFilterType === 'by-countries' || uniqueFilterType === 'names') {
                    tieBreakerList = finalCandidates;
                }
                else if(sortFilterType === 'longest' || lenFilter === 'longest') {
                    const best = finalCandidates[0].length;
                    tieBreakerList = finalCandidates.filter(w => w.length === best);
                } else if (sortFilterType === 'shortest' || lenFilter === 'shortest') {
                    const best = finalCandidates[0].length;
                    tieBreakerList = finalCandidates.filter(w => w.length === best);
                } else if (sortFilterType === 'common') {
                    const best = wordFrequencyMap.get(finalCandidates[0]);
                    tieBreakerList = finalCandidates.filter(w => wordFrequencyMap.get(w) === best);
                } else if (sortFilterType === 'least-common') {
                    const best = wordFrequencyMap.get(finalCandidates[0]);
                    tieBreakerList = finalCandidates.filter(w => wordFrequencyMap.get(w) === best);
                } else {
                    tieBreakerList = finalCandidates;
                }
                
                if(tieBreakerList.length === 0) {
                     resultsContainer.textContent = `No *new* words found for that combo.`;
                    return;
                }

                const randomWord = tieBreakerList[Math.floor(Math.random() * tieBreakerList.length)];
                const formattedWord = applyCapping(randomWord, capMode);
                
                copyToClipboard(formattedWord, randomWord, null, query);
                addToHistory(randomWord, query, uniqueFilterType, sortFilterType, capMode);
            }
            
            // --- NEW: Define Word Function (with Fallback) ---
            async function defineWord(word) {
                defineModalTitle.textContent = `Defining "${word}"...`;
                defineSearchInput.value = word;
                
                document.getElementById('define-modal-summary').innerHTML = '<em>Loading...</em>';
                document.getElementById('define-modal-full').innerHTML = '<em>Loading...</em>';
                showDefineTab('summary');
                
                defineModalOverlay.style.display = 'flex';
                
                try {
                    // --- Attempt 1: Primary API ---
                    const data = await fetchDictionaryApi(word);
                    populateDefineModal(data);
                    
                } catch (error) {
                    console.warn(`Primary API failed for "${word}", trying Wiktionary...`);
                    try {
                        // --- Attempt 2: Wiktionary Fallback ---
                        const data = await fetchWiktionaryApi(word);
                        populateDefineModal(data);
                        
                    } catch (fallbackError) {
                        // --- Both Failed ---
                        console.error(`All definition sources failed for "${word}"`);
                        defineModalTitle.textContent = `Define Word`;
                        const errorHtml = `<p>Sorry, no definition found for "${word}".</p>`;
                        document.getElementById('define-modal-summary').innerHTML = errorHtml;
                        document.getElementById('define-modal-full').innerHTML = errorHtml;
                    }
                }
            }

            async function fetchDictionaryApi(word) {
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (!response.ok) {
                    throw new Error('Word not found in dictionaryapi.dev');
                }
                const data = await response.json();
                
                const entry = data[0];
                let summaryHtml = '';
                let fullHtml = '';
                
                fullHtml += `<h3>${entry.word} <small style="color: var(--text-muted-color);">${entry.phonetic || ''}</small></h3>`;
                
                entry.meanings.forEach(meaning => {
                    fullHtml += `<h4>(${meaning.partOfSpeech})</h4>`;
                    meaning.definitions.forEach((def, index) => {
                        fullHtml += `<p><b>${index + 1}.</b> ${def.definition}</p>`;
                        if (def.example) {
                            fullHtml += `<p><em>e.g., "${def.example}"</em></p>`;
                        }
                    });
                });
                
                if (entry.meanings[0] && entry.meanings[0].definitions[0]) {
                    summaryHtml = `<h3>${entry.word} <small style="color: var(--text-muted-color);">${entry.phonetic || ''}</small></h3>`;
                    summaryHtml += `<h4>(${entry.meanings[0].partOfSpeech})</h4>`;
                    summaryHtml += `<p><b>1.</b> ${entry.meanings[0].definitions[0].definition}</p>`;
                    if (entry.meanings[0].definitions[0].example) {
                        summaryHtml += `<p><em>e.g., "${entry.meanings[0].definitions[0].example}"</em></p>`;
                    }
                } else {
                    summaryHtml = fullHtml;
                }
                
                return { title: `Definition for "${entry.word}"`, summaryHtml, fullHtml };
            }

            async function fetchWiktionaryApi(word) {
                const response = await fetch(`https://en.wiktionary.org/api/rest_v1/page/definition/${word}`);
                if (!response.ok) {
                    throw new Error('Word not found in Wiktionary');
                }
                const data = await response.json();
                
                const entry = data.en[0]; // Get first English entry
                if (!entry || !entry.definitions || entry.definitions.length === 0) {
                     throw new Error('Wiktionary entry has no definitions');
                }
                
                let summaryHtml = '';
                let fullHtml = '';
                
                fullHtml += `<h3>${entry.word} <small style="color: var(--text-muted-color);">(from Wiktionary)</small></h3>`;
                
                data.en.forEach(meaningSection => {
                    fullHtml += `<h4>(${meaningSection.partOfSpeech})</h4>`;
                    meaningSection.definitions.forEach((def, index) => {
                        fullHtml += `<p><b>${index + 1}.</b> ${def.definition}</p>`; 
                    });
                });
                
                summaryHtml = `<h3>${entry.word} <small style="color: var(--text-muted-color);">(from Wiktionary)</small></h3>`;
                summaryHtml += `<h4>(${entry.partOfSpeech})</h4>`;
                summaryHtml += `<p><b>1.</b> ${entry.definitions[0].definition}</p>`;

                return { title: `Definition for "${entry.word}"`, summaryHtml, fullHtml };
            }
            
            function populateDefineModal({ title, summaryHtml, fullHtml }) {
                defineModalTitle.textContent = title;
                document.getElementById('define-modal-summary').innerHTML = summaryHtml;
                document.getElementById('define-modal-full').innerHTML = fullHtml;
            }
            
            function showDefineTab(tabId) {
                document.querySelectorAll('.modal-tab').forEach(tab => tab.classList.remove('active'));
                document.querySelectorAll('.modal-tab-content').forEach(content => content.classList.remove('active'));
                
                document.querySelector(`.modal-tab[data-tab="${tabId}"]`).classList.add('active');
                document.getElementById(`define-modal-${tabId}`).classList.add('active');
            }
            
            // --- speakWord (Unchanged) ---
            function speakWord(word) {
                synth.cancel(); 
                const utterance = new SpeechSynthesisUtterance(word);
                synth.speak(utterance);
            }
            
            // --- Stats Modal Functions (Unchanged) ---
            function calculateStatsAndPrompts() {
                dictionaryStats.totalWords = allCleanWords.length;
                dictionaryStats.freqWords = wordFrequencyMap.size;
                let totalLength = 0;
                let maxLength = 0;
                const lengthMap = new Map();
                for (const word of allCleanWords) {
                    const len = word.length;
                    totalLength += len;
                    lengthMap.set(len, (lengthMap.get(len) || 0) + 1);
                    if (len > maxLength) maxLength = len;
                    
                    if (word.length >= 3) {
                        for (let i = 0; i <= word.length - 3; i++) {
                            const prompt = word.substring(i, i + 3);
                            if (!threeLetterPromptMap.has(prompt)) {
                                threeLetterPromptMap.set(prompt, new Set());
                            }
                            threeLetterPromptMap.get(prompt).add(word);
                        }
                    }
                }
                
                threeLetterPromptMap.forEach((wordSet, prompt) => {
                    const count = wordSet.size;
                    if (!promptsByCountMap.has(count)) {
                        promptsByCountMap.set(count, []);
                    }
                    promptsByCountMap.get(count).push(prompt);
                });
                
                dictionaryStats.avgLength = (totalLength / allCleanWords.length).toFixed(1);
                dictionaryStats.lengthDistribution = lengthMap;
                dictionaryStats.maxLength = maxLength;
                populateLengthFilter(maxLength);
                console.log(`Pre-calculated ${threeLetterPromptMap.size} 3-letter prompts.`);
            }
            function populateLengthFilter(maxLength) {
                const fragment = document.createDocumentFragment();
                for (let i = 1; i <= maxLength; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `Length = ${i}`;
                    fragment.appendChild(option);
                }
                lengthFilter.appendChild(fragment);
            }
            function populateStatsModal() {
                statTotalWords.textContent = dictionaryStats.totalWords.toLocaleString();
                statFreqWords.textContent = dictionaryStats.freqWords.toLocaleString();
                statAvgLength.textContent = dictionaryStats.avgLength;
                statsChart.innerHTML = '';
                let maxCount = 0;
                for (const count of dictionaryStats.lengthDistribution.values()) {
                    if (count > maxCount) maxCount = count;
                }
                for (let i = 1; i <= dictionaryStats.maxLength; i++) {
                    const count = dictionaryStats.lengthDistribution.get(i) || 0;
                    if (count === 0) continue; 
                    const bar = document.createElement('div');
                    bar.className = 'chart-bar';
                    const heightPercent = (count / maxCount) * 100;
                    bar.style.height = `${heightPercent}%`;
                    bar.innerHTML = `<span class="bar-label">${i}</span>`;
                    bar.title = `${count.toLocaleString()} words of length ${i}`;
                    statsChart.appendChild(bar);
                }
                
                const totalCopied = allCopiedWords.size;
                const gameSessionsCount = gameSessions.length;
                let avgWords = 0;
                const totalGameWords = gameSessions.reduce((acc, s) => acc + s.words.length, 0);
                if (gameSessionsCount > 0) {
                    avgWords = (totalGameWords / gameSessionsCount).toFixed(1);
                }
                statTotalCopied.textContent = totalCopied.toLocaleString();
                statGameSessions.textContent = gameSessionsCount.toLocaleString();
                statAvgWordsGame.textContent = avgWords;
            }

            // --- Event Listeners ---
            searchForm.addEventListener('submit', handleSearch);
            themeToggleButton.addEventListener('click', toggleTheme);
            function toggleTheme() {
                document.body.classList.remove(themes[currentTheme]);
                currentTheme = (currentTheme + 1) % themes.length;
                const newTheme = themes[currentTheme];
                document.body.classList.add(newTheme);
                saveState();
            }

            // --- Include/Exclude Listeners (Unchanged) ---
            function renderIncludeExcludeTags() {
                includeListTags.innerHTML = '';
                permanentIncludeList.forEach(item => {
                    const tag = document.createElement('span');
                    tag.className = 'filter-tag filter-tag-include';
                    tag.textContent = item;
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-tag-btn';
                    removeBtn.innerHTML = '&times;';
                    removeBtn.dataset.item = item;
                    tag.appendChild(removeBtn);
                    includeListTags.appendChild(tag);
                });
                excludeListTags.innerHTML = '';
                permanentExcludeList.forEach(item => {
                    const tag = document.createElement('span');
                    tag.className = 'filter-tag filter-tag-exclude';
                    tag.textContent = item;
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-tag-btn';
                    removeBtn.innerHTML = '&times;';
                    removeBtn.dataset.item = item;
                    tag.appendChild(removeBtn);
                    excludeListTags.appendChild(tag);
                });
            }
            addIncludeButton.addEventListener('click', () => {
                const query = searchInput.value.trim().toLowerCase();
                if (query.length > 0 && !permanentIncludeList.includes(query)) {
                    permanentIncludeList.push(query);
                    searchInput.value = '';
                    renderIncludeExcludeTags();
                    saveState();
                }
            });
            addExcludeButton.addEventListener('click', () => {
                const query = searchInput.value.trim().toLowerCase();
                if (query.length > 0 && !permanentExcludeList.includes(query)) {
                    permanentExcludeList.push(query);
                    searchInput.value = '';
                    renderIncludeExcludeTags();
                    saveState();
                }
            });
            includeListTags.addEventListener('click', (e) => {
                if (e.target.classList.contains('remove-tag-btn')) {
                    const item = e.target.dataset.item;
                    permanentIncludeList = permanentIncludeList.filter(i => i !== item);
                    renderIncludeExcludeTags();
                    saveState();
                }
            });
            excludeListTags.addEventListener('click', (e) => {
                if (e.target.classList.contains('remove-tag-btn')) {
                    const item = e.target.dataset.item;
                    permanentExcludeList = permanentExcludeList.filter(i => i !== item);
                    renderIncludeExcludeTags();
                    saveState();
                }
            });

            // (Game Toggle and Softlock listeners unchanged)
            gameToggleButton.addEventListener('click', () => {
                isGameMode = !isGameMode;
                if (isGameMode) {
                    gameToggleButton.textContent = 'End Game';
                    gameToggleButton.classList.add('game-active');
                    softlockButton.style.display = 'inline-block';
                    resultsContainer.innerHTML = 'Game Mode Started!';
                    searchInput.placeholder = "e.g., ing";
                    const date = new Date().toLocaleDateString('en-GB');
                    currentGameSession = { id: Date.now(), name: `Game - ${date}`, words: [] };
                    gameSessions.push(currentGameSession);
                    updateHistoryPanel();
                    saveState();
                } else {
                    gameToggleButton.textContent = 'Start Game';
                    gameToggleButton.classList.remove('game-active');
                    softlockButton.style.display = 'none';
                    resultsContainer.innerHTML = 'Game Mode Ended.';
                    searchInput.placeholder = "e.g., s_a_e";
                    currentGameSession = null; 
                    if (isSoftlocked) {
                        toggleSoftlock();
                    }
                    updateHistoryPanel();
                    saveState();
                }
            });
            softlockButton.addEventListener('click', () => {
                toggleSoftlock();
            });
            function toggleSoftlock() {
                isSoftlocked = !isSoftlocked;
                if (isSoftlocked) {
                    softlockBuffer = "";
                    document.body.classList.add('softlocked');
                    softlockButton.textContent = 'Unlock';
                    resultsContainer.innerHTML = `Softlock On. Start typing... (Press Shift to search)`;
                } else {
                    document.body.classList.remove('softlocked');
                    softlockButton.textContent = 'Softlock';
                    resultsContainer.innerHTML = 'Softlock Off.';
                }
            }
            document.addEventListener('keydown', (e) => {
                if (!isGameMode || !isSoftlocked) {
                    return;
                }
                e.preventDefault(); 
                if (e.key === 'Shift') {
                    handleSearch(null); 
                } else if (e.key === 'Backspace') {
                    softlockBuffer = softlockBuffer.slice(0, -1);
                } else if (e.key.length === 1) {
                    softlockBuffer += e.key;
                }
                if (e.key !== 'Shift') {
                    resultsContainer.innerHTML = `Softlock On. Prompt: <strong class="highlight">${softlockBuffer}</strong> (Press Shift to search)`;
                }
            });

            resetButton.addEventListener('click', () => {
                document.querySelectorAll('.word-item.copied').forEach(el => {
                    el.classList.remove('copied');
                });
                document.querySelectorAll('.word-item.word-bomb-selected').forEach(el => {
                    el.classList.remove('word-bomb-selected');
                });
                wordBombSelected.clear();
            });
            
            toggleHistoryButton.addEventListener('click', () => historyPanel.classList.toggle('open'));
            closeHistoryButton.addEventListener('click', () => historyPanel.classList.remove('open'));
            
            statsButton.addEventListener('click', () => {
                populateStatsModal(); 
                statsModalOverlay.style.display = 'flex';
            });
            statsCloseButton.addEventListener('click', () => {
                statsModalOverlay.style.display = 'none';
            });
            statsModalOverlay.addEventListener('click', (e) => {
                if (e.target === statsModalOverlay) {
                    statsModalOverlay.style.display = 'none';
                }
            });
            
            // --- NEW: Define Modal Listeners ---
            defineToggleButton.addEventListener('click', () => {
                isDefineMode = !isDefineMode;
                if (isDefineMode) {
                    defineToggleButton.classList.add('active');
                    defineSearchInput.value = '';
                    defineModalTitle.textContent = 'Define Word';
                    document.getElementById('define-modal-summary').innerHTML = 'Type a word in the box above or click a word in the results.';
                    document.getElementById('define-modal-full').innerHTML = '';
                    showDefineTab('summary');
                    defineModalOverlay.style.display = 'flex';
                } else {
                    defineToggleButton.classList.remove('active');
                    defineModalOverlay.style.display = 'none';
                }
            });
            defineCloseButton.addEventListener('click', () => {
                defineModalOverlay.style.display = 'none';
                isDefineMode = false;
                defineToggleButton.classList.remove('active');
            });
            defineModalOverlay.addEventListener('click', (e) => {
                if (e.target === defineModalOverlay) {
                    defineModalOverlay.style.display = 'none';
                    isDefineMode = false;
                    defineToggleButton.classList.remove('active');
                }
            });
            defineModalNav.addEventListener('click', (e) => {
                if (e.target.classList.contains('modal-tab')) {
                    showDefineTab(e.target.dataset.tab);
                }
            });
            defineSearchForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const word = defineSearchInput.value.trim();
                if (word) {
                    defineWord(word);
                }
            });
            
            // --- NEW: Crazy Mode Listener ---
            crazyModeButton.addEventListener('click', () => {
                isCrazyMode = !isCrazyMode;
                if (isCrazyMode) {
                    crazyModeButton.classList.add('active');
                    crazyModeButton.textContent = 'Crazy Mode ON ðŸ¤ª';
                } else {
                    crazyModeButton.classList.remove('active');
                    crazyModeButton.textContent = 'Crazy Mode ðŸ¤ª';
                }
            });
            
            historySearchInput.addEventListener('input', () => {
                updateHistoryPanel();
            });
            
            // --- NEW: Prompt Page Listeners ---
            promptPageButton.addEventListener('click', showPromptsPage);
            promptHomeButton.addEventListener('click', showMainApp);
            promptSort.addEventListener('change', renderPromptsList);
            
            promptsListContainer.addEventListener('click', (e) => {
                const promptItem = e.target.closest('.prompt-item');
                if (promptItem) {
                    renderPromptWords(promptItem.dataset.prompt);
                }
            });
            
            // --- NEW: SubSearch Page Listeners ---
            subsearchPageButton.addEventListener('click', showSubSearchPage);
            subsearchHomeButton.addEventListener('click', showMainApp);
            subsearchForm.addEventListener('submit', handleSubSearch);
            
            subsearchList.addEventListener('click', (e) => {
                const promptItem = e.target.closest('.prompt-item');
                if (promptItem) {
                    renderPromptWords(promptItem.dataset.prompt);
                }
            });
            
            function showMainApp() {
                mainAppDiv.style.display = 'flex';
                promptsPageDiv.style.display = 'none';
                subsearchPageDiv.style.display = 'none';
                resultsContainer.innerHTML = '';
            }
            
            function showPromptsPage() {
                mainAppDiv.style.display = 'none';
                subsearchPageDiv.style.display = 'none';
                promptsPageDiv.style.display = 'block';
                renderPromptsList();
            }
            
            function showSubSearchPage() {
                mainAppDiv.style.display = 'none';
                promptsPageDiv.style.display = 'none';
                subsearchPageDiv.style.display = 'block';
                subsearchList.innerHTML = '';
            }

            function renderPromptsList() {
                const sortBy = promptSort.value;
                let sortedPrompts = Array.from(threeLetterPromptMap.entries());
                
                if (sortBy === 'count') {
                    sortedPrompts.sort((a, b) => b[1].size - a[1].size);
                } else {
                    sortedPrompts.sort((a, b) => a[0].localeCompare(b[0]));
                }
                
                const fragment = document.createDocumentFragment();
                for (const [prompt, wordSet] of sortedPrompts) {
                    const item = document.createElement('div');
                    item.className = 'prompt-item';
                    item.dataset.prompt = prompt;
                    
                    const hasCopied = Array.from(wordSet).some(word => allCopiedWords.has(word));
                    
                    item.innerHTML = `
                        <div>
                            <span class="prompt-name">${prompt}</span>
                            <span class="prompt-info">(${wordSet.size} words)</span>
                        </div>
                        <span class="prompt-check" style="color: ${hasCopied ? 'var(--check-color)' : 'var(--reset-color)'};">${hasCopied ? 'âœ“' : 'âœ—'}</span>
                    `;
                    fragment.appendChild(item);
                }
                promptsListContainer.innerHTML = '';
                promptsListContainer.appendChild(fragment);
            }
            
            function handleSubSearch(event) {
                if (event) event.preventDefault();
                const targetCount = parseInt(subsearchInput.value, 10);
                
                if (isNaN(targetCount) || targetCount <= 0) {
                    subsearchList.innerHTML = '<p style="color: var(--reset-color);">Please enter a valid number.</p>';
                    return;
                }
                
                const matchingPrompts = promptsByCountMap.get(targetCount) || [];
                
                if (matchingPrompts.length === 0) {
                    subsearchList.innerHTML = `<p>No 3-letter prompts found with exactly ${targetCount} words.</p>`;
                    return;
                }
                
                const fragment = document.createDocumentFragment();
                matchingPrompts.sort();
                
                for (const prompt of matchingPrompts) {
                    const item = document.createElement('div');
                    item.className = 'prompt-item';
                    item.dataset.prompt = prompt;
                    
                    const wordSet = threeLetterPromptMap.get(prompt);
                    const hasCopied = Array.from(wordSet).some(word => allCopiedWords.has(word));
                    
                    item.innerHTML = `
                        <div>
                            <span class="prompt-name">${prompt}</span>
                            <span class="prompt-info">(${wordSet.size} words)</span>
                        </div>
                        <span class="prompt-check" style="color: ${hasCopied ? 'var(--check-color)' : 'var(--reset-color)'};">${hasCopied ? 'âœ“' : 'âœ—'}</span>
                    `;
                    fragment.appendChild(item);
                }
                subsearchList.innerHTML = '';
                subsearchList.appendChild(fragment);
            }
            
            function renderPromptWords(prompt) {
                const wordSet = threeLetterPromptMap.get(prompt) || new Set();
                const wordList = Array.from(wordSet);
                const capMode = getEffectiveCapMode();
                
                showMainApp();
                resultsContainer.innerHTML = '';
                
                const header = document.createElement('h3');
                header.innerHTML = `Words for: <span class="highlight">${prompt}</span>`;
                resultsContainer.appendChild(header);

                if (wordList.length === 0) {
                    resultsContainer.innerHTML += 'No words found for this prompt.';
                    return;
                }
                
                const filterType = 'none';
                const lenFilter = lengthFilter.value;
                
                let displayList;
                if (lenFilter === 'longest') {
                    displayList = wordList.sort((a, b) => b.length - a.length);
                } else if (lenFilter === 'shortest') {
                    displayList = wordList.sort((a, b) => a.length - b.length);
                } else if (lenFilter !== 'any') {
                    const length = parseInt(lenFilter, 10);
                    displayList = wordList.filter(w => w.length === length);
                } else {
                    displayList = wordList.sort();
                }
                
                const totalMatches = displayList.length;
                const wordsToDisplay = displayList.slice(0, MAX_RESULTS_TO_DISPLAY);
                
                const summary = document.createElement('div');
                summary.id = 'results-summary';
                summary.textContent = `Showing ${wordsToDisplay.length} of ${totalMatches} matching words.`;
                resultsContainer.appendChild(summary);

                const fragment = document.createDocumentFragment();
                for (const originalWord of wordsToDisplay) {
                    const wordElement = document.createElement('span');
                    const formattedWord = applyCapping(originalWord, capMode);
                    const highlightedHtml = highlightQuery(formattedWord, prompt);
                    const ttsIcon = `<span class="tts-icon">ðŸ”Š</span>`;
                    const hasCopied = allCopiedWords.has(originalWord);
                    const checkIcon = `<span class="tts-icon" style="color: ${hasCopied ? 'var(--check-color)' : 'var(--reset-color)'};">${hasCopied ? 'âœ“' : 'âœ—'}</span>`;

                    wordElement.innerHTML = highlightedHtml + ttsIcon + checkIcon;
                    wordElement.className = 'word-item';
                    wordElement.dataset.originalWord = originalWord;
                    
                    if (hasCopied) {
                        wordElement.classList.add('copied');
                    }
                    fragment.appendChild(wordElement);
                }
                resultsContainer.appendChild(fragment);
            }

            // --- UPDATED: Results Container Listeners ---
            resultsContainer.addEventListener('mouseover', (e) => {
                const target = e.target.closest('.word-item');
                if (target) {
                    const originalWord = target.dataset.originalWord;
                    const tooltipText = getTooltipText(originalWord);
                    if (tooltipText) {
                        const rect = target.getBoundingClientRect();
                        tooltip.textContent = tooltipText;
                        tooltip.style.left = `${rect.left + (rect.width / 2)}px`;
                        tooltip.style.top = `${rect.top + window.scrollY}px`;
                        tooltip.style.display = 'block';
                    }
                }
            });
            resultsContainer.addEventListener('mouseout', (e) => {
                if (e.target.closest('.word-item')) {
                    tooltip.style.display = 'none';
                }
            });
            
            resultsContainer.addEventListener('click', (e) => {
                const target = e.target;
                const query = isSoftlocked ? softlockBuffer.trim().toLowerCase() : searchInput.value.trim().toLowerCase();
                const uniqueFilterType = uniqueFilter.value;
                const sortFilterType = searchFilter.value;
                const capMode = getEffectiveCapMode();
                
                if (target.classList.contains('tts-icon')) {
                    e.stopPropagation();
                    const formattedWord = target.closest('.word-item').textContent.replace(/ðŸ”Š|ðŸ“–|âœ“|âœ—/g,'').trim();
                    speakWord(formattedWord);
                    return;
                }
                
                const wordElement = target.closest('.word-item');
                if (wordElement) {
                    const originalWord = wordElement.dataset.originalWord;
                    const formattedWord = wordElement.textContent.replace(/ðŸ”Š|ðŸ“–|âœ“|âœ—/g,'').trim();
                    
                    if (isDefineMode) {
                        defineWord(originalWord);
                        isDefineMode = false;
                        defineToggleButton.classList.remove('active');
                        return;
                    }
                    
                    if (uniqueFilterType === 'word-bomb') {
                        if (wordBombSelected.has(originalWord)) {
                            wordBombSelected.delete(originalWord);
                            wordElement.classList.remove('word-bomb-selected');
                        } else {
                            wordBombSelected.add(originalWord);
                            wordElement.classList.add('word-bomb-selected');
                        }
                    } else {
                        copyToClipboard(formattedWord, originalWord, wordElement, query);
                        addToHistory(originalWord, query, uniqueFilterType, sortFilterType, capMode);
                    }
                }
            });
            
            resultsContainer.addEventListener('dblclick', (e) => {
                const wordElement = e.target.closest('.word-item');
                if (wordElement) {
                    const originalWord = wordElement.dataset.originalWord;
                    defineWord(originalWord);
                }
            });
            
            resultsContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault(); 
                const wordElement = e.target.closest('.word-item');
                if (wordElement) {
                    const originalWord = wordElement.dataset.originalWord;
                    if (wordBombList.has(originalWord)) {
                        wordBombList.delete(originalWord);
                        tooltip.textContent = `Removed "${originalWord}" from Word-Bomb!`;
                    } else {
                        wordBombList.add(originalWord);
                        tooltip.textContent = `Added "${originalWord}" to Word-Bomb!`;
                    }
                    saveState();
                    wordElement.style.transition = 'transform 0.1s ease-out';
                    wordElement.style.transform = 'scale(1.1)';
                    setTimeout(() => {
                        wordElement.style.transform = 'scale(1)';
                    }, 100);
                }
            });

            // --- History Panel click listener (Unchanged) ---
            historyContent.addEventListener('click', (e) => {
                const target = e.target;
                const sessionElement = target.closest('.game-session');
                if (!sessionElement) return;
                
                if (target.classList.contains('rename-btn')) {
                    const summary = target.closest('summary');
                    const sessionNameSpan = summary.querySelector('.session-name');
                    sessionNameSpan.contentEditable = "true";
                    sessionNameSpan.focus();
                    sessionNameSpan.addEventListener('blur', saveRename, { once: true });
                    sessionNameSpan.addEventListener('keydown', (keyEvent) => {
                        if (keyEvent.key === 'Enter') {
                            keyEvent.preventDefault();
                            sessionNameSpan.blur();
                        }
                    });
                }
                if (target.classList.contains('delete-session-btn')) {
                    if (confirm('Delete this game session?')) {
                        const sessionId = sessionElement.dataset.sessionId;
                        gameSessions = gameSessions.filter(s => s.id.toString() !== sessionId);
                        updateHistoryPanel();
                        saveState();
                    }
                }
                if (target.classList.contains('delete-word-btn')) {
                    if (sessionElement.classList.contains('locked')) return;
                    const sessionId = sessionElement.dataset.sessionId;
                    const wordToDelete = target.dataset.word;
                    const session = gameSessions.find(s => s.id.toString() === sessionId);
                    if (session) {
                        session.words = session.words.filter(item => item.word !== wordToDelete);
                        updateHistoryPanel();
                        saveState();
                    }
                }
            });
            function saveRename(e) {
                const sessionNameSpan = e.target;
                sessionNameSpan.contentEditable = "false";
                const sessionId = sessionNameSpan.closest('.game-session').dataset.sessionId;
                const session = gameSessions.find(s => s.id.toString() === sessionId);
                if (session) session.name = sessionNameSpan.textContent.trim();
                saveState();
            }

            // --- Load Saved Data & Word Files ---
            loadState();
            loadAndProcessFile();
        });
    

/* --- New Panel management and injected behaviors from the user's block --- */
/* Panel Management */
function closeAllPanels() {
    document.getElementById('left-panel').classList.remove('open');
    document.getElementById('right-panel').classList.remove('open');
    document.getElementById('history-panel').classList.remove('open');
}

function openLeftPanel(content) {
    closeAllPanels();
    document.getElementById('left-panel-content').innerHTML = content;
    document.getElementById('left-panel').classList.add('open');
}

function openRightPanel(content) {
    closeAllPanels();
    document.getElementById('right-panel-content').innerHTML = content;
    document.getElementById('right-panel').classList.add('open');
}

function determinePanelSide(buttonElement) {
    const buttonRect = buttonElement.getBoundingClientRect();
    const screenCenter = window.innerWidth / 2;
    return buttonRect.left < screenCenter ? 'left' : 'right';
}

// Close button listeners
document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.panel-close-btn').forEach(btn => {
        btn.addEventListener('click', closeAllPanels);
    });

    // Unique Filter Button
    document.getElementById('unique-filter-btn').addEventListener('click', function() {
        const content = `
            <h2>Unique Filter</h2>
            <button class="option-btn" data-value="none">Standard Search</button>
            <button class="option-btn" data-value="by-countries">By Countries</button>
            <button class="option-btn" data-value="names">Names</button>
            <button class="option-btn" data-value="word-bomb">Word-Bomb List</button>
            <button class="option-btn" data-value="pattern">Pattern (_)</button>
            <button class="option-btn" data-value="v-c-pattern">V/C Pattern (v/c)</button>
            <button class="option-btn" data-value="anagram">Anagram</button>
            <button class="option-btn" data-value="include-all">Include All Letters</button>
        `;

        const side = determinePanelSide(this);
        if (side === 'left') openLeftPanel(content);
        else openRightPanel(content);

        // delegate events (panels created dynamically)
        setTimeout(() => {
            document.querySelectorAll('.option-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    if(window.uniqueFilter) {
                        window.uniqueFilter.value = btn.dataset.value;
                    }
                    closeAllPanels();
                });
            });
        }, 50);
    });

    // Sort Filter Button
    document.getElementById('sort-filter-btn').addEventListener('click', function() {
        const content = `
            <h2>Sort By</h2>
            <button class="option-btn" data-value="none">None (Shuffle)</button>
            <button class="option-btn" data-value="starting">Starting With</button>
            <button class="option-btn" data-value="ending">Ending With</button>
            <button class="option-btn" data-value="common">Most Common</button>
            <button class="option-btn" data-value="least-common">Least Common</button>
        `;

        const side = determinePanelSide(this);
        if (side === 'left') openLeftPanel(content);
        else openRightPanel(content);

        setTimeout(() => {
            document.querySelectorAll('.option-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    if(window.searchFilter) {
                        window.searchFilter.value = btn.dataset.value;
                    }
                    closeAllPanels();
                });
            });
        }, 50);
    });

    // Length Filter Button with all operators
    document.getElementById('length-filter-btn').addEventListener('click', function() {
        const content = `
            <h2>Length Filter</h2>
            <input type="number" id="length-input" placeholder="Enter number" min="1">
            <div class="length-btn-grid">
                <button class="option-btn" data-op="<">x &lt;</button>
                <button class="option-btn" data-op="<=">x â‰¤</button>
                <button class="option-btn" data-op=">">x &gt;</button>
                <button class="option-btn" data-op=">=">x â‰¥</button>
                <button class="option-btn" data-op="=">x =</button>
                <button class="option-btn" data-op="!=">x â‰ </button>
            </div>
            <button class="option-btn" data-op="range">&lt;x&lt;</button>
            <div id="range-input-container">
                <input type="number" id="range-min" placeholder="Min" min="1">
                <span>&lt; x &lt;</span>
                <input type="number" id="range-max" placeholder="Max" min="1">
                <button class="btn" id="apply-range-btn">Apply</button>
            </div>
            <hr style="margin: 15px 0; border-color: var(--history-border);">
            <button class="option-btn" data-value="longest">Longest</button>
            <button class="option-btn" data-value="shortest">Shortest</button>
            <button class="option-btn" data-value="random">Random</button>
            <button class="option-btn" data-value="any">Any Length</button>
        `;

        const side = determinePanelSide(this);
        if (side === 'left') openLeftPanel(content);
        else openRightPanel(content);

        setTimeout(() => {
            document.querySelectorAll('.option-btn[data-op]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const op = btn.dataset.op;
                    if (op === 'range') {
                        document.getElementById('range-input-container').classList.add('active');
                    } else {
                        const value = document.getElementById('length-input').value;
                        if (value) {
                            if(window.lengthFilter) {
                                window.lengthFilter.value = op + value;
                            }
                            closeAllPanels();
                        }
                    }
                });
            });

            document.getElementById('apply-range-btn')?.addEventListener('click', () => {
                const min = document.getElementById('range-min').value;
                const max = document.getElementById('range-max').value;
                if (min && max && parseInt(min) < parseInt(max)) {
                    if(window.lengthFilter) {
                        window.lengthFilter.value = `${min}<x<${max}`;
                    }
                    closeAllPanels();
                }
            });

            document.querySelectorAll('.option-btn[data-value]').forEach(btn => {
                btn.addEventListener('click', () => {
                    if(window.lengthFilter) {
                        window.lengthFilter.value = btn.dataset.value;
                    }
                    closeAllPanels();
                });
            });
        }, 50);
    });

    // Caps Filter Button
    document.getElementById('caps-filter-btn').addEventListener('click', function() {
        const content = `
            <h2>Capitalization</h2>
            <button class="option-btn" data-value="none">None-Capped</button>
            <button class="option-btn" data-value="all">All Capped</button>
            <button class="option-btn" data-value="random-letter">Random Caps</button>
            <button class="option-btn" data-value="random-mode">Random Mode</button>
        `;

        const side = determinePanelSide(this);
        if (side === 'left') openLeftPanel(content);
        else openRightPanel(content);

        setTimeout(() => {
            document.querySelectorAll('.option-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    if(window.capFilter) {
                        window.capFilter.value = btn.dataset.value;
                    }
                    closeAllPanels();
                });
            });
        }, 50);
    });

    // Include/Exclude Button
    document.getElementById('include-exclude-btn').addEventListener('click', function() {
        const content = `
            <h2>Include/Exclude</h2>
            <div style="margin-bottom: 20px;">
                <label>Add to Search:</label>
                <div style="display: flex; gap: 5px; margin-top: 5px;">
                    <input type="text" id="add-filter-input" placeholder="Enter text" style="flex: 1; padding: 8px; border-radius: 4px; border: 1px solid var(--history-border); background: var(--input-bg-color); color: var(--text-color);">
                    <button class="btn" id="add-include-btn-panel" style="background: var(--include-color);">Include</button>
                    <button class="btn" id="add-exclude-btn-panel" style="background: var(--exclude-color);">Exclude</button>
                </div>
            </div>
            <div class="filter-tags-container">
                <h3>Include:</h3>
                <div id="include-tags-panel"></div>
            </div>
            <div class="filter-tags-container">
                <h3>Exclude:</h3>
                <div id="exclude-tags-panel"></div>
            </div>
        `;

        const side = determinePanelSide(this);
        if (side === 'left') openLeftPanel(content);
        else openRightPanel(content);

        setTimeout(() => {
            // render existing lists if available
            function renderIncludeExcludeTagsInPanelLocal() {
                const includeContainer = document.getElementById('include-tags-panel');
                const excludeContainer = document.getElementById('exclude-tags-panel');
                if (!includeContainer || !excludeContainer) return;
                const incList = window.permanentIncludeList || [];
                const excList = window.permanentExcludeList || [];
                includeContainer.innerHTML = incList.map(item => `<span class="filter-tag filter-tag-include">${item}<button class="remove-tag-btn" data-list="include" data-item="${item}">Ã—</button></span>`).join('');
                excludeContainer.innerHTML = excList.map(item => `<span class="filter-tag filter-tag-exclude">${item}<button class="remove-tag-btn" data-list="exclude" data-item="${item}">Ã—</button></span>`).join('');
                document.querySelectorAll('.remove-tag-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const list = btn.dataset.list;
                        const item = btn.dataset.item;
                        if (list === 'include') {
                            window.permanentIncludeList = (window.permanentIncludeList || []).filter(i => i !== item);
                        } else {
                            window.permanentExcludeList = (window.permanentExcludeList || []).filter(i => i !== item);
                        }
                        renderIncludeExcludeTagsInPanelLocal();
                        if(window.saveState) window.saveState();
                    });
                });
            }
            renderIncludeExcludeTagsInPanelLocal();

            document.getElementById('add-include-btn-panel').addEventListener('click', () => {
                const input = document.getElementById('add-filter-input');
                const value = input.value.trim().toLowerCase();
                if (value) {
                    window.permanentIncludeList = window.permanentIncludeList || [];
                    if (!window.permanentIncludeList.includes(value)) {
                        window.permanentIncludeList.push(value);
                    }
                    input.value = '';
                    renderIncludeExcludeTagsInPanelLocal();
                    if(window.saveState) window.saveState();
                }
            });
            document.getElementById('add-exclude-btn-panel').addEventListener('click', () => {
                const input = document.getElementById('add-filter-input');
                const value = input.value.trim().toLowerCase();
                if (value) {
                    window.permanentExcludeList = window.permanentExcludeList || [];
                    if (!window.permanentExcludeList.includes(value)) {
                        window.permanentExcludeList.push(value);
                    }
                    input.value = '';
                    renderIncludeExcludeTagsInPanelLocal();
                    if(window.saveState) window.saveState();
                }
            });
        }, 50);
    });

    // history toggle
    document.getElementById('toggle-history-button').addEventListener('click', () => {
        document.getElementById('history-panel').classList.toggle('open');
    });
    document.getElementById('close-history-btn').addEventListener('click', () => {
        document.getElementById('history-panel').classList.remove('open');
    });

});
</script>
</html>
